<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document Editor</title>
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        .upload-section {
            padding: 30px;
            border-bottom: 1px solid #eee;
        }
        
        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            background: #f8f9ff;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .upload-area:hover {
            border-color: #764ba2;
            background: #f0f2ff;
        }
        
        .upload-area.dragover {
            border-color: #764ba2;
            background: #e8ecff;
        }
        
        .upload-icon {
            font-size: 3em;
            color: #667eea;
            margin-bottom: 20px;
        }
        
        .file-input {
            display: none;
        }
        
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            margin: 10px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .editor-section {
            display: none;
            padding: 30px;
        }
        
        .three-column-layout {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        .column {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            min-height: 600px;
            border: 1px solid #e9ecef;
        }
        
        .column-header {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }
        
        .pdf-preview {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            height: 500px;
            overflow-y: auto;
            font-family: 'Times New Roman', serif;
            line-height: 1.6;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .tags-preview {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            height: 500px;
            overflow-y: auto;
        }
        
        .tag-item {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .tag-item:hover {
            background: #e9ecef;
            border-color: #667eea;
        }
        
        .tag-label {
            font-weight: bold;
            color: #667eea;
            font-size: 14px;
            margin-bottom: 5px;
        }
        
        .tag-value {
            color: #333;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            background: white;
            padding: 3px 6px;
            border-radius: 3px;
            border: 1px solid #ddd;
        }
        
        .form-container {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            height: 500px;
            overflow-y: auto;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-label {
            display: block;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .form-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            font-family: 'Times New Roman', serif;
        }
        
        .form-textarea {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            font-family: 'Times New Roman', serif;
            min-height: 80px;
            resize: vertical;
        }
        
        .status {
            padding: 15px;
            margin: 20px 0;
            border-radius: 8px;
            text-align: center;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status.loading {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .submit-section {
            margin-top: 30px;
            text-align: center;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .submit-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .submit-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìÑ Document Editor</h1>
            <p>Upload PDF documents and edit them with exact formatting preservation</p>
        </div>
        
        <div class="upload-section">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">üìÅ</div>
                <h3>Upload Your Document</h3>
                <p>Drag and drop your PDF or DOC file here or click to browse</p>
                <input type="file" id="fileInput" class="file-input" accept=".pdf,.doc,.docx">
                <button class="btn" onclick="document.getElementById('fileInput').click()">
                    Choose Document File
                </button>
            </div>
            
            <div id="status" class="status" style="display: none;"></div>
        </div>
        
        <div class="editor-section" id="editorSection">
            <div class="three-column-layout">
                                 <!-- Column 1: Live PDF Preview -->
                 <div class="column">
                     <div class="column-header">üìÑ Live PDF Preview</div>
                     <div id="pdfPreview" class="pdf-preview">
                         <p style="text-align: center; color: #666; margin-top: 200px;">
                             Live preview will appear here after upload
                         </p>
                     </div>
                 </div>
                
                <!-- Column 2: Extracted Tags -->
                <div class="column">
                    <div class="column-header">üè∑Ô∏è Extracted Tags & Fields</div>
                    <div id="tagsPreview" class="tags-preview">
                        <p style="text-align: center; color: #666; margin-top: 200px;">
                            Extracted tags will appear here
                        </p>
                    </div>
                </div>
                
                <!-- Column 3: Form Fields -->
                <div class="column">
                    <div class="column-header">‚úèÔ∏è Edit Form Fields</div>
                    <div id="formContainer" class="form-container">
                        <p style="text-align: center; color: #666; margin-top: 200px;">
                            Form fields will appear here
                        </p>
                    </div>
                </div>
            </div>
            
            <div class="submit-section">
                <button class="submit-btn" onclick="submitAndDownload()">
                    üíæ Submit & Download PDF
                </button>
            </div>
        </div>
    </div>

    <script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>
    <script>
        let extractedData = null;
        let formData = {};

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            setupFileUpload();
        });

        // Setup file upload functionality
        function setupFileUpload() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');

            // Drag and drop functionality
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFileUpload(files[0]);
                }
            });

            // File input change
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFileUpload(e.target.files[0]);
                }
            });
        }

        // Handle file upload
        async function handleFileUpload(file) {
            const validExtensions = ['.pdf', '.doc', '.docx'];
            const fileExtension = file.name.toLowerCase();
            const isValidFile = validExtensions.some(ext => fileExtension.endsWith(ext));
            
            if (!isValidFile) {
                showStatus('Please select a PDF or DOC file.', 'error');
                return;
            }

            showStatus('Uploading and processing document...', 'loading');

            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                                 if (response.ok) {
                     extractedData = data.content;
                     // Store parsed data from backend
                     window.parsedData = data.parsed_data || {};
                     // Store the order of sections as they appear in the document
                     window.parsedDataOrder = data.parsed_data_order || [];
                     // Store original structure for formatting preservation
                     window.originalStructure = data.original_structure || {};
                     
                     showStatus('Document processed successfully!', 'success');
                     // Initialize with live preview
                     displayOriginalPdf(extractedData);
                     extractAndDisplayTags(extractedData);
                     createFormFields();
                     showEditor();
                     
                     // Show initial live preview
                     updateLivePreviewRealTime();
                 } else {
                     showStatus(`Error: ${data.error}`, 'error');
                 }
            } catch (error) {
                showStatus(`Upload failed: ${error.message}`, 'error');
            }
        }

        // Show status message
        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.innerHTML = type === 'loading' ? 
                `<div class="loading-spinner"></div>${message}` : 
                message;
            status.className = `status ${type}`;
            status.style.display = 'block';
        }

        // Display original PDF content with exact formatting
        function displayOriginalPdf(content) {
            const pdfPreview = document.getElementById('pdfPreview');
            let html = '';
            
            content.forEach(item => {
                const text = item.insert;
                const attributes = item.attributes;
                
                let style = '';
                if (attributes.bold) style += 'font-weight: bold; ';
                if (attributes.italic) style += 'font-style: italic; ';
                if (attributes.font) style += `font-family: "${attributes.font}", serif; `;
                if (attributes.size) style += `font-size: ${attributes.size}px; `;
                
                html += `<span style="${style}">${text}</span>`;
            });
            
            pdfPreview.innerHTML = html;
        }

                 // Extract and display tags
         function extractAndDisplayTags(content) {
             const tagsPreview = document.getElementById('tagsPreview');
             
             // Use parsed data from backend if available, otherwise fallback to client-side extraction
             let tags = {};
             
             if (window.parsedData) {
                 tags = window.parsedData;
             } else {
                 tags = extractTagsFromContent(content);
             }
             
             let html = '';
             // Maintain original document order by using the order from the backend
             const tagOrder = window.parsedDataOrder || Object.keys(tags);
             
             tagOrder.forEach(tagName => {
                 if (tags[tagName]) {
                     const value = tags[tagName];
                     const displayValue = Array.isArray(value) ? value.join(', ') : value;
                     
                     html += `
                         <div class="tag-item">
                             <div class="tag-label">${getFieldIcon(tagName)} ${tagName}</div>
                             <div class="tag-value">${displayValue}</div>
                         </div>
                     `;
                 }
             });
             
             tagsPreview.innerHTML = html;
         }

        // Extract tags from content (fallback method)
        function extractTagsFromContent(content) {
            const tags = {};
            let currentText = '';
            
            content.forEach(item => {
                currentText += item.insert;
            });
            
            // Extract sections based on headings and subheadings
            const sections = extractSectionsFromContent(content);
            
            // Create tags for each section
            Object.keys(sections).forEach(sectionName => {
                tags[sectionName] = sections[sectionName];
            });
            
            return tags;
        }

        // Extract sections based on headings and subheadings
        function extractSectionsFromContent(content) {
            const sections = {};
            let currentSection = '';
            let currentContent = '';
            
            content.forEach(item => {
                const text = item.insert;
                const attributes = item.attributes;
                
                // Check if this is a heading (bold text, larger font, or all caps)
                const isHeading = (
                    attributes.bold || 
                    (attributes.size && attributes.size > 12) ||
                    (text.trim().length > 0 && text.trim().length < 50 && text.trim() === text.trim().toUpperCase())
                );
                
                if (isHeading && text.trim()) {
                    // Save previous section if exists
                    if (currentSection && currentContent.trim()) {
                        sections[currentSection] = currentContent.trim();
                    }
                    
                    // Start new section
                    currentSection = text.trim().replace(/[:\n]/g, '').trim();
                    currentContent = '';
                } else {
                    // Add to current section content
                    currentContent += text;
                }
            });
            
            // Save the last section
            if (currentSection && currentContent.trim()) {
                sections[currentSection] = currentContent.trim();
            }
            
            // If no sections found, try smart pattern extraction
            if (Object.keys(sections).length === 0) {
                return extractSmartPatterns(content);
            }
            
            return sections;
        }

        // Extract smart patterns for common resume fields
        function extractSmartPatterns(content) {
            const sections = {};
            let fullText = '';
            
            content.forEach(item => {
                fullText += item.insert;
            });
            
            // Smart pattern recognition
            const patterns = [
                // Name patterns (capitalized words, typically 2-4 words)
                { 
                    name: 'Name', 
                    pattern: /^([A-Z][a-z]+(?:\s+[A-Z][a-z]+){1,3})/,
                    priority: 1 
                },
                
                // Phone number patterns
                { 
                    name: 'Mobile Number', 
                    pattern: /(\+91[-\s]?\d{10}|\+1[-\s]?\(?\d{3}\)?[-\s]?\d{3}[-\s]?\d{4}|\d{10})/,
                    priority: 2 
                },
                
                // Email patterns
                { 
                    name: 'Email', 
                    pattern: /([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/,
                    priority: 3 
                },
                
                // Address patterns (lines with street numbers, cities, states)
                { 
                    name: 'Address', 
                    pattern: /(\d+\s+[A-Za-z\s]+(?:Street|St|Avenue|Ave|Road|Rd|Lane|Ln|Drive|Dr|Boulevard|Blvd)[,\s]+[A-Za-z\s]+(?:City|Town|Village)[,\s]+[A-Za-z\s]+)/i,
                    priority: 4 
                },
                
                // Date of Birth patterns
                { 
                    name: 'Date of Birth', 
                    pattern: /(?:DOB|Date of Birth|Birth Date)[:\s]*(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4})/i,
                    priority: 5 
                },
                
                // Education patterns
                { 
                    name: 'Education', 
                    pattern: /(?:EDUCATION|Education|Academic|Qualifications)[:\s]*([\s\S]*?)(?=\n[A-Z]{3,}|$)/i,
                    priority: 6 
                },
                
                // Experience patterns
                { 
                    name: 'Experience', 
                    pattern: /(?:EXPERIENCE|Experience|Work History|Employment)[:\s]*([\s\S]*?)(?=\n[A-Z]{3,}|$)/i,
                    priority: 7 
                },
                
                // Skills patterns
                { 
                    name: 'Skills', 
                    pattern: /(?:SKILLS|Skills|Technical Skills|Competencies)[:\s]*([\s\S]*?)(?=\n[A-Z]{3,}|$)/i,
                    priority: 8 
                },
                
                // Projects patterns
                { 
                    name: 'Projects', 
                    pattern: /(?:PROJECTS|Projects|Project Work)[:\s]*([\s\S]*?)(?=\n[A-Z]{3,}|$)/i,
                    priority: 9 
                },
                
                // Achievements patterns
                { 
                    name: 'Achievements', 
                    pattern: /(?:ACHIEVEMENTS|Achievements|Awards|Certifications)[:\s]*([\s\S]*?)(?=\n[A-Z]{3,}|$)/i,
                    priority: 10 
                },
                
                // Career Objective patterns
                { 
                    name: 'Career Objective', 
                    pattern: /(?:CAREER OBJECTIVE|Career Objective|Objective|Summary)[:\s]*([\s\S]*?)(?=\n[A-Z]{3,}|$)/i,
                    priority: 11 
                },
                
                // Personal Details patterns
                { 
                    name: 'Personal Details', 
                    pattern: /(?:PERSONAL DETAILS|Personal Details|Personal Information)[:\s]*([\s\S]*?)(?=\n[A-Z]{3,}|$)/i,
                    priority: 12 
                },
                
                // Languages patterns
                { 
                    name: 'Languages', 
                    pattern: /(?:LANGUAGES|Languages|Language Skills|Linguistic)[:\s]*([\s\S]*?)(?=\n[A-Z]{3,}|$)/i,
                    priority: 13 
                },
                
                // Hobbies patterns
                { 
                    name: 'Hobbies', 
                    pattern: /(?:HOBBIES|Hobbies|Interests|Activities)[:\s]*([\s\S]*?)(?=\n[A-Z]{3,}|$)/i,
                    priority: 14 
                }
            ];
            
            // Sort patterns by priority
            patterns.sort((a, b) => a.priority - b.priority);
            
            // Extract sections using patterns
            patterns.forEach(pattern => {
                const match = fullText.match(pattern.pattern);
                if (match) {
                    // Clean up the extracted content
                    let content = match[1] || match[0];
                    content = content.trim();
                    
                    // Remove the extracted content from fullText to avoid duplicates
                    fullText = fullText.replace(match[0], '');
                    
                    if (content && content.length > 2) {
                        sections[pattern.name] = content;
                    }
                }
            });
            
            // If still no sections found, create basic ones from lines
            if (Object.keys(sections).length === 0) {
                const lines = fullText.split('\n').filter(line => line.trim());
                if (lines.length > 0) sections['Name'] = lines[0].trim();
                if (lines.length > 1) sections['Address'] = lines[1].trim();
                if (lines.length > 2) sections['Contact'] = lines[2].trim();
            }
            
            return sections;
        }

                 // Create form fields
         function createFormFields() {
             const formContainer = document.getElementById('formContainer');
             
             // Use parsed data from backend if available, otherwise fallback to client-side extraction
             let tags = {};
             
             if (window.parsedData) {
                 tags = window.parsedData;
             } else {
                 tags = extractTagsFromContent(extractedData);
             }
             
             let html = '';
             // Maintain original document order by using the order from the backend
             const tagOrder = window.parsedDataOrder || Object.keys(tags);
             
             tagOrder.forEach(tagName => {
                 if (tags[tagName]) {
                     const value = tags[tagName];
                     const displayValue = Array.isArray(value) ? value.join(', ') : value;
                     const isMultiline = displayValue.length > 100 || displayValue.includes('\n') || displayValue.includes('‚Ä¢') || displayValue.includes('¬∑');
                     const icon = getFieldIcon(tagName);
                     
                     html += `
                         <div class="form-group">
                             <label class="form-label">${icon} ${tagName}</label>
                             ${isMultiline ? 
                                 `<textarea class="form-textarea" id="form_${tagName}" placeholder="Edit ${tagName.toLowerCase()} content...">${displayValue}</textarea>` :
                                 `<input type="text" class="form-input" id="form_${tagName}" value="${displayValue}" placeholder="Edit ${tagName.toLowerCase()}...">`
                             }
                             <div style="font-size: 11px; color: #666; margin-top: 3px;">
                                 ${displayValue.length} characters
                             </div>
                         </div>
                     `;
                 }
             });
             
             formContainer.innerHTML = html;
            
                                 // Initialize form data
         Object.keys(tags).forEach(tagName => {
             const element = document.getElementById(`form_${tagName}`);
             if (element) {
                 formData[tagName] = element.value;
                 element.addEventListener('input', (e) => {
                     formData[tagName] = e.target.value;
                     // Update character count
                     const charCount = e.target.parentElement.querySelector('div');
                     if (charCount) {
                         charCount.textContent = `${e.target.value.length} characters`;
                     }
                     
                     // Real-time live update the PDF preview
                     updateLivePreviewRealTime();
                     
                     // Auto-save changes
                     autoSaveChanges();
                 });
             }
         });
        }

        // Get appropriate icon for field type
        function getFieldIcon(fieldName) {
            const iconMap = {
                'Name': 'üë§',
                'Mobile Number': 'üì±',
                'Email': 'üìß',
                'Address': 'üìç',
                'Date of Birth': 'üéÇ',
                'Education': 'üéì',
                'Experience': 'üíº',
                'Skills': '‚ö°',
                'Technical Skills': '‚ö°',
                'Projects': 'üöÄ',
                'Achievements': 'üèÜ',
                'Career Objective': 'üéØ',
                'Personal Details': 'üë§',
                'Languages': 'üó£Ô∏è',
                'Co Curricular': 'üé®',
                'Co-curricular': 'üé®',
                'Contact': 'üìû',
                'Phone': 'üì±',
                'Website': 'üåê',
                'LinkedIn': 'üíº',
                'GitHub': 'üêô',
                'Portfolio': 'üìÅ'
            };
            
            return iconMap[fieldName] || 'üìù';
        }

        // Show editor section
        function showEditor() {
            document.getElementById('editorSection').style.display = 'block';
            document.getElementById('editorSection').scrollIntoView({ 
                behavior: 'smooth' 
            });
        }

        // Submit and download PDF
        async function submitAndDownload() {
            if (!extractedData) {
                showStatus('No content to export', 'error');
                return;
            }
            
            showStatus('Generating PDF with exact formatting...', 'loading');
            
            try {
                // Use the current updated content (with all changes)
                const contentToExport = window.currentUpdatedContent || updateContentWithFormData(extractedData, formData);
                
                const response = await fetch('/export', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ content: contentToExport })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    // Convert base64 to blob and download
                    const pdfData = atob(data.pdf_data);
                    const pdfBlob = new Blob([new Uint8Array(pdfData.length).map((_, i) => pdfData.charCodeAt(i))], {
                        type: 'application/pdf'
                    });
                    
                    // Create download link
                    const downloadLink = document.createElement('a');
                    downloadLink.href = URL.createObjectURL(pdfBlob);
                    downloadLink.download = data.filename;
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                    
                    showStatus('PDF downloaded successfully with exact formatting!', 'success');
                } else {
                    showStatus(`Export failed: ${data.error}`, 'error');
                }
            } catch (error) {
                showStatus(`Export failed: ${error.message}`, 'error');
            }
        }

        // Update content with form data
        function updateContentWithFormData(originalContent, formData) {
            const updatedContent = [...originalContent];
            
            // Create a map of section names to their content
            const sections = extractSectionsFromContent(originalContent);
            
            Object.keys(formData).forEach(sectionName => {
                const newValue = formData[sectionName];
                if (newValue && sections[sectionName]) {
                    // Find the section in the original content and replace it
                    let sectionStartIndex = -1;
                    let sectionEndIndex = -1;
                    let currentSection = '';
                    let currentContent = '';
                    
                    // Find the section boundaries
                    for (let i = 0; i < updatedContent.length; i++) {
                        const item = updatedContent[i];
                        const text = item.insert;
                        const attributes = item.attributes;
                        
                        const isHeading = (
                            attributes.bold || 
                            (attributes.size && attributes.size > 12) ||
                            (text.trim().length > 0 && text.trim().length < 50 && text.trim() === text.trim().toUpperCase())
                        );
                        
                        if (isHeading && text.trim()) {
                            // Check if this is our target section
                            const headingText = text.trim().replace(/[:\n]/g, '').trim();
                            if (headingText === sectionName) {
                                sectionStartIndex = i;
                                currentSection = headingText;
                                currentContent = '';
                            } else if (currentSection === sectionName) {
                                // We've reached the next section, so this is the end
                                sectionEndIndex = i;
                                break;
                            }
                        } else if (currentSection === sectionName) {
                            currentContent += text;
                        }
                    }
                    
                    // If we found the section, replace it
                    if (sectionStartIndex !== -1) {
                        if (sectionEndIndex === -1) {
                            sectionEndIndex = updatedContent.length;
                        }
                        
                        // Remove the old section content (keep the heading)
                        updatedContent.splice(sectionStartIndex + 1, sectionEndIndex - sectionStartIndex - 1);
                        
                        // Add the new content with EXACT original formatting
                        const newContentLines = newValue.split('\n');
                        newContentLines.forEach((line, index) => {
                            if (line.trim()) {
                                // Find the original formatting for this section
                                const originalFormatting = findOriginalFormatting(sectionName, originalContent);
                                
                                const newItem = {
                                    insert: line + (index < newContentLines.length - 1 ? '\n' : ''),
                                    attributes: {
                                        ...originalFormatting,
                                        bold: false, // Content is usually not bold
                                        size: originalFormatting.size || 11 // Preserve original size
                                    }
                                };
                                updatedContent.splice(sectionStartIndex + 1 + index, 0, newItem);
                            }
                        });
                    }
                }
            });
            
            return updatedContent;
        }

        // Find original formatting for a section
        function findOriginalFormatting(sectionName, originalContent) {
            // Look for the original formatting in the content
            for (let i = 0; i < originalContent.length; i++) {
                const item = originalContent[i];
                const text = item.insert;
                
                // Check if this is the section we're looking for
                if (text.toLowerCase().includes(sectionName.toLowerCase())) {
                    return item.attributes;
                }
            }
            
            // Default formatting if not found
            return {
                font: 'TimesNewRomanPSMT',
                size: 11,
                bold: false,
                italic: false
            };
        }

                 // Real-time live preview update function
         function updateLivePreviewRealTime() {
             if (!extractedData) return;
             
             // Update the content with current form data
             const updatedContent = updateContentWithFormData(extractedData, formData);
             
             // Update the PDF preview with new content in real-time
             displayOriginalPdf(updatedContent);
             
             // Store the updated content for download
             window.currentUpdatedContent = updatedContent;
             
             // Show a subtle indicator that preview is updating
             showPreviewUpdateIndicator();
             
             // Force a visual update
             const pdfPreview = document.getElementById('pdfPreview');
             if (pdfPreview) {
                 pdfPreview.style.display = 'none';
                 setTimeout(() => {
                     pdfPreview.style.display = 'block';
                 }, 10);
             }
         }
         
         // Show preview update indicator
         function showPreviewUpdateIndicator() {
             const pdfPreview = document.getElementById('pdfPreview');
             const indicator = document.createElement('div');
             indicator.style.cssText = `
                 position: absolute;
                 top: 10px;
                 right: 10px;
                 background: #28a745;
                 color: white;
                 padding: 6px 12px;
                 border-radius: 6px;
                 font-size: 12px;
                 font-weight: bold;
                 z-index: 1000;
                 animation: fadeInOut 1.5s ease-in-out;
                 box-shadow: 0 2px 8px rgba(0,0,0,0.2);
             `;
             indicator.textContent = 'üîÑ Live Preview';
             
             // Add CSS animation
             const style = document.createElement('style');
             style.textContent = `
                 @keyframes fadeInOut {
                     0% { opacity: 0; transform: translateY(-10px); }
                     20% { opacity: 1; transform: translateY(0); }
                     80% { opacity: 1; transform: translateY(0); }
                     100% { opacity: 0; transform: translateY(-10px); }
                 }
             `;
             document.head.appendChild(style);
             
             pdfPreview.style.position = 'relative';
             pdfPreview.appendChild(indicator);
             
             // Remove indicator after animation
             setTimeout(() => {
                 if (indicator.parentNode) {
                     indicator.parentNode.removeChild(indicator);
                 }
             }, 1500);
         }

        // Auto-save changes function
        function autoSaveChanges() {
            if (!extractedData) return;
            
            // Update the content with current form data
            const updatedContent = updateContentWithFormData(extractedData, formData);
            
            // Store the updated content
            window.currentUpdatedContent = updatedContent;
            
            // Show a subtle save indicator
            showStatus('Changes saved automatically', 'success');
            setTimeout(() => {
                const status = document.getElementById('status');
                if (status && status.textContent.includes('Changes saved automatically')) {
                    status.style.display = 'none';
                }
            }, 2000);
        }
    </script>
</body>
</html> 